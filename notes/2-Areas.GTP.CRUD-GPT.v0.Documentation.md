---
id: 7myal67wl3tahx4xdy9kqxf
title: Documentation
desc: ''
updated: 1742536234697
created: 1742536234697
---
## Comprehensive Documentation and Guides

The system comes with thorough **documentation for both developers and future maintainers**, all written in clear Markdown for accessibility. This includes:

- **Architecture Overview:** A top-level README (much like this document) explains the overall system architecture, the rationale behind the multi-GPT workflow, and how the pieces fit together. It uses diagrams and structured text to ensure a human developer (or new team member) can understand how we orchestrated ChatGPT to build the application. Key concepts (like what is a Prompter GPT vs a Worker GPT, how the team hierarchy is structured) are defined with industry-standard terminology. The documentation draws parallels to real-world agile teams and uses verbose explanations where necessary to make the process clear.
- **Organizational Chart & Role Descriptions:** We include a visual org chart of the GPT teams and workgroups, illustrating the hierarchy and information flow (as described above). Each role (each GPT agent) has a one-paragraph description of its purpose. For example: "*Page Worker GPT – generates Next.js page components based on design specs. Inputs: structured page requirements from Page Prompter. Outputs: `.tsx` page code with JSX, using Components team outputs as needed.*" This section of the docs helps users quickly identify which GPT to use or troubleshoot for a given aspect (if the login page has an issue, check the Page GPT output; if the data isn’t saving, check the Model/API GPT outputs, etc.).
- **User Guide (Step-by-Step Workflow):** A detailed guide walks through using the system, from setup to deployment (see next section for a summary of steps). It covers how to instantiate each custom GPT in the ChatGPT app (including what system prompt or custom instructions to use for each role), how to prepare inputs (e.g. formatting a PRD into the expected format for the Prompter), and how to pass outputs between chats. We break down an example feature from start to finish in a tutorial style. For instance, the guide might demonstrate building a “Task Tracker” feature: starting with the PRD, then showing how the Frontend Prompter GPT produces a task list, how the Frontend Worker GPT outputs code for a Task page, how the Backend GPTs create a Task model and API, and how all that is assembled and tested. Screenshots or code snippets are used to illustrate what each step’s conversation might look like (ensuring the user knows what to copy-paste). This step-by-step portion also includes **troubleshooting tips** at each stage – e.g., “If the output from the Worker GPT is incomplete or stops mid-code, try prompting it with ‘continue from X’ or ask the Prompter to split the task into smaller chunks.” We emphasize the importance of verifying each step’s result before moving on, essentially teaching the user to act as the project manager overseeing the AI workgroups.
- **Maintenance and Update Procedures:** The documentation outlines how to update the system itself. If the tech stack changes (say Next.js 16 introduces a new folder structure, or we switch from MongoDB to a different database), how do we update the GPT prompts/templates? We provide a guide on modifying or extending the prompt templates and rules. For example, “to support a new workgroup for Notifications, create a new Custom GPT with similar structure to the others, and add its integration points in the App Team’s instructions.” We also cover how to upgrade the GPTs if OpenAI releases new features – for instance, in the future the manual copy-paste might be replaced by function calling or an API, so we mention where in the workflow such an integration could occur. Essentially, this acts as the **maintenance manual** for our AI system, ensuring it’s not a black box but a well-documented toolset that others can adjust.
- **Best Practices & Conventions:** To make the project sustainable, we document all the coding conventions used. This includes language specific tips (like how we use TypeScript generics or React hooks in this project) and general principles (e.g. “prefer functional components and React hooks over class components” or “all state management should use React Context or hooks provided in `lib/state.ts`”). Having these in the docs means the GPT outputs can also be benchmarked against them by human developers. We also cite relevant sources or references (for example, we might reference the official Next.js docs or Tailwind docs where applicable) to back up our choices. The documentation is written in a professional tone and organized with headings, bullet lists, and examples, so that it’s easy to navigate (whether viewed on GitHub, in an editor, or as printed).
- **Troubleshooting & FAQ:** We dedicate a section for common issues and their solutions. 

    For example: 
“**Q:** The Frontend Worker GPT output is throwing a TypeScript error about mismatched types. 
**A:** This might mean the Types workgroup wasn’t run or integrated yet. Ensure that the Type System team has provided the necessary type definitions, or run the Type Checker GPT to update types.” 
    Another: 
“**Q:** The QA GPT keeps indicating an authentication error in the API, how do I fix this? 
**A:** Possibly the Auth workgroup’s output wasn’t integrated. You might need to prompt the Auth GPT to generate an auth middleware and include it in the API route.” 

This FAQ acts as a quick reference for users as they use the system, especially important given the manual nature of gluing outputs – it helps them immediately know which GPT to consult or re-run when a particular class of problem arises.

All documentation is kept in Markdown for easy reading and editing. We use diagrams (with textual alternatives) where appropriate to illustrate complex workflows. By maintaining comprehensive docs, we ensure that the system is **transparent and maintainable** – any engineer can read through it and understand the what, why, and how. 

It demystifies the structured prompt workflow and allows continuous improvement (readers are welcome to suggest new rules for QA GPTs or add more templates as needed). In summary, the documentation serves as both a user manual and an internal knowledge base for the AI-assisted development system, ensuring long-term viability.